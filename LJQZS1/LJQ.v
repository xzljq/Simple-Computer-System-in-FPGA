
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module LJQ(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


wire [31:0] imemaddr;
wire [31:0] imemdataout;
wire imemclk;
wire [31:0] dmemaddr;
reg [31:0] dmemdataout;
wire [31:0] dmemdatain;
wire dmemrdclk;
wire dmemwrclk;
wire [2:0] MemOp;
wire enable;
wire [31:0] PC;
wire [31:0] memtemp1;
wire [31:0] memtemp2;
wire [31:0] memtemp3;

wire my_clock;



wire [9:0] h_addr;
wire [9:0] v_addr;
wire read;
wire [23:0] data;

reg [11:0] point [4095:0];
//reg [7:0] screen_mem [3839:0];
wire [7:0] ascii;
wire [7:0] midvar;
wire [11:0] pos;


//wire [3:0] num0, num1, num2, num3, num4, num5;



//=======================================================
//  Structural coding
//=======================================================

// =========================  CPU  ============================//

always @ (dmemaddr) begin
	case (dmemaddr[31:20])
		12'h001 : dmemdataout = memtemp1;
		12'h003 : dmemdataout = memtemp2;
		12'h004 : dmemdataout = memtemp3;
		default : dmemdataout = 12'b0;
	endcase
end

exp11 CPU(
	.clock (my_clock),
	.reset (SW[0]),
	
	.imemaddr (imemaddr),
	.imemdataout (imemdataout),
	.imemclk (imemclk),
	
	.dmemaddr (dmemaddr),
	.dmemdataout (dmemdataout),
	.dmemdatain (dmemdatain),
	.dmemrdclk (dmemrdclk),
	.dmemwrclk (dmemwrclk),
	.dmemop (MemOp),
	.dmemwe (enable),
	
	.dbgdata (PC)
);
 

clkgen #(100000) clkgen_mod(
   .clkin (CLOCK_50),
	.rst (SW[1]),
	.clken (1'b1),
	.clkout (my_clock)
);


// ==================== mem =============== //

dmem data_mem(
	.addr (dmemaddr[19:0]),
	.dataout (memtemp1),
	.datain (dmemdatain),
	.rdclk (dmemrdclk),
	.wrclk (dmemwrclk),
	.memop (MemOp),
	.we (dmemaddr[31:20]==12'h001 && enable)
	
);


vmem visual_mem(
	.wraddr (dmemaddr[19:0]),
	.rdline (v_addr),
	.rdcol(h_addr),
	.dataout (ascii),
	.datain (dmemdatain),
	.wrclk (dmemwrclk),
	.we (dmemaddr[31:20]==12'h002  && enable)
	
);


imem instr_mem(
	.addr (imemaddr),
	.dataout (imemdataout),
	.rdclk (imemclk),
	.we (1'b0),
	.memop (3'b010)
);


assign memtemp2 = {24'b0, key};


assign memtemp3 = {24'b0, T};

always @ (posedge dmemwrclk) begin
	if(enable && dmemaddr[31:20]==12'h005) begin
		HDW[dmemaddr[3:0]] <= dmemdatain[7:0];
	end
end


// =========================  SCREEN  ============================= //



initial begin
	$readmemh("point.txt", point, 0, 4095);
	//screen_mem[0] = 8'h41;
	//screen_mem[1] = 8'h44;
	//screen_mem[2] = 8'h43;
	//screen_mem[3] = 8'h42;
end

clkgen #(25000000) clk_VGA(CLOCK_50, 1'b0, 1'b1, VGA_CLK);

//assign pos = (({2'b00, v_addr} >> 4) << 7) + (h_addr/9);
//assign ascii = screen_mem[pos];
assign midvar = point[{ascii, v_addr[3:0]}];
assign read = midvar[h_addr%9];
assign data = (read)? 24'hFFFFFF: 24'h000000;
assign VGA_SYNC_N = 0;

vga_ctrl VGA(
 .pclk (VGA_CLK), 
 .reset ( 1'b0 ), 
 .vga_data (data), 
 .h_addr (h_addr),
 .v_addr (v_addr),
 .hsync (VGA_HS),
 .vsync (VGA_VS),
 .valid (VGA_BLANK_N),
 .vga_r (VGA_R),
 .vga_g (VGA_G),
 .vga_b (VGA_B)
 );	

 
 // ================================ keyboard ======================= //
 
 wire [7:0] key;
 
 
 keyboard my_kb(
	.clk (CLOCK_50),
	.clrn (1'b1),
	.ps2_clk (PS2_CLK),
	.ps2_data (PS2_DAT),
	.ascii_key (key),
	.shift (LEDR[9]),
	.ctrl (LEDR[8]),
	.caps (LEDR[7])
); 


// ========================== time ============================== //

reg [31:0] T;
reg [31:0] cnt_time;

initial begin
	T = 32'b0;
	cnt_time = 32'b0;
end

always @ (posedge CLOCK_50) begin
	if(dmemaddr[31:20]==12'h004 && enable) begin
		T <= dmemdatain;
	end
	else begin
		if(cnt_time == 32'd4999) begin
			cnt_time <= 32'b0;
			
			if(T==32'd863_999_999) T <= 32'b0;
			else T <= T + 1;
		end
		else cnt_time <= cnt_time + 1;
	end
end


// ============================ hardware ===================================//

reg [7:0] HDW [15:0];

//initial begin
//	HDW[0] = 8'b0;
//	HDW[1] = 8'b0;
//	HDW[2] = 8'b0;
//	HDW[3] = 8'b0;
//	HDW[4] = 8'b0;
//	HDW[5] = 8'b0;
//	HDW[6] = 8'b0;
//	HDW[7] = 8'b0;
//	HDW[8] = 8'b0;
//	HDW[9] = 8'b0;
//	HDW[10] = 8'b0;
//	HDW[11] = 8'b0;
//	HDW[12] = 8'b0;
//	HDW[13] = 8'b0;
//	HDW[14] = 8'b0;
//	HDW[15] = 8'b0;
//end

assign LEDR[0] = (|HDW[0]);
assign LEDR[1] = (|HDW[1]);
assign LEDR[2] = (|HDW[2]);
assign LEDR[3] = (|HDW[3]);
assign LEDR[4] = (|HDW[4]);
assign LEDR[5] = (|HDW[5]);
assign LEDR[6] = (|HDW[6]);

bcd7seg hex0 (1'b1, HDW[10], HEX0);
bcd7seg hex1 (1'b1, HDW[11], HEX1);
bcd7seg hex2 (1'b1, HDW[12], HEX2);
bcd7seg hex3 (1'b1, HDW[13], HEX3);
bcd7seg hex4 (1'b1, HDW[14], HEX4);
bcd7seg hex5 (1'b1, HDW[15], HEX5);

endmodule
